// bmb-math: Mathematical functions and constants for BMB
// Standard mathematical operations with contract verification

// Constants (as functions due to BMB's expression-based design)
fn pi() -> i64 = 3141592653;  // pi * 10^9 for integer precision
fn e() -> i64 = 2718281828;   // e * 10^9 for integer precision

// Absolute value
fn abs(x: i64) -> i64
  post ret >= 0
= if x < 0 { 0 - x } else { x };

// Minimum of two values
fn min(a: i64, b: i64) -> i64
  post ret <= a and ret <= b
= if a < b { a } else { b };

// Maximum of two values
fn max(a: i64, b: i64) -> i64
  post ret >= a and ret >= b
= if a > b { a } else { b };

// Clamp value between min and max
fn clamp(x: i64, lo: i64, hi: i64) -> i64
  pre lo <= hi
  post ret >= lo and ret <= hi
= max(lo, min(hi, x));

// Sign of a number (-1, 0, or 1)
fn sign(x: i64) -> i64
  post ret >= -1 and ret <= 1
= if x < 0 { -1 } else if x > 0 { 1 } else { 0 };

// Power function (x^n for non-negative n)
fn pow_iter(base: i64, exp: i64, acc: i64) -> i64 =
    if exp <= 0 { acc } else { pow_iter(base, exp - 1, acc * base) };

fn pow(base: i64, exp: i64) -> i64
  pre exp >= 0
= pow_iter(base, exp, 1);

// Square root using Newton's method (integer approximation)
fn sqrt_iter(n: i64, guess: i64, prev: i64) -> i64 =
    if guess == prev { guess } else { sqrt_iter(n, (guess + n / guess) / 2, guess) };

fn sqrt(n: i64) -> i64
  pre n >= 0
  post ret * ret <= n
= if n == 0 { 0 } else if n == 1 { 1 } else { sqrt_iter(n, n / 2, 0) };

// Greatest Common Divisor (Euclidean algorithm)
fn gcd(a: i64, b: i64) -> i64
  pre a >= 0 and b >= 0
  post ret >= 0
= if b == 0 { a } else { gcd(b, a - (a / b) * b) };

// Least Common Multiple
fn lcm(a: i64, b: i64) -> i64
  pre a > 0 and b > 0
  post ret >= a and ret >= b
= (a / gcd(a, b)) * b;

// Factorial
fn factorial_iter(n: i64, acc: i64) -> i64 =
    if n <= 1 { acc } else { factorial_iter(n - 1, acc * n) };

fn factorial(n: i64) -> i64
  pre n >= 0
  post ret >= 1
= factorial_iter(n, 1);

// Fibonacci
fn fib_iter(n: i64, a: i64, b: i64) -> i64 =
    if n <= 0 { a } else { fib_iter(n - 1, b, a + b) };

fn fib(n: i64) -> i64
  pre n >= 0
= fib_iter(n, 0, 1);

// Check if number is prime
fn is_prime_check(n: i64, d: i64) -> bool =
    if d * d > n { true } else if n - (n / d) * d == 0 { false } else { is_prime_check(n, d + 2) };

fn is_prime(n: i64) -> bool
  pre n >= 0
= if n < 2 { false } else if n == 2 { true } else if n - (n / 2) * 2 == 0 { false } else { is_prime_check(n, 3) };
