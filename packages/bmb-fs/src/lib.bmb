// bmb-fs: File system path utilities for BMB
// Provides path manipulation and validation

// Path separator constants
fn path_sep_unix() -> i64 = 47;   // /
fn path_sep_win() -> i64 = 92;    // \
fn path_sep() -> i64 = 47;        // default to Unix style

// Extension separator
fn ext_sep() -> i64 = 46;  // .

// Check if path is absolute (Unix-style)
fn is_absolute(path: String) -> bool =
    path.len() > 0 and path.byte_at(0) == path_sep();

// Check if path is relative
fn is_relative(path: String) -> bool = not is_absolute(path);

// Find last separator position
fn find_last_sep_iter(path: String, pos: i64, last: i64) -> i64 =
    if pos >= path.len() { last } else if path.byte_at(pos) == path_sep() { find_last_sep_iter(path, pos + 1, pos) } else { find_last_sep_iter(path, pos + 1, last) };

fn find_last_sep(path: String) -> i64 = find_last_sep_iter(path, 0, -1);

// Get directory name (parent path)
fn dirname_end(path: String) -> i64 =
    let last = find_last_sep(path);
    if last < 0 { 0 } else if last == 0 { 1 } else { last };

// Get base name (file name with extension)
fn basename_start(path: String) -> i64 =
    let last = find_last_sep(path);
    if last < 0 { 0 } else { last + 1 };

// Find extension position (last dot after last separator)
fn find_ext_iter(path: String, pos: i64, last_dot: i64, last_sep: i64) -> i64 =
    if pos >= path.len() { last_dot } else {
        let c = path.byte_at(pos);
        if c == path_sep() { find_ext_iter(path, pos + 1, 0 - 1, pos) }
        else if c == ext_sep() { find_ext_iter(path, pos + 1, pos, last_sep) }
        else { find_ext_iter(path, pos + 1, last_dot, last_sep) }
    };

fn find_ext(path: String) -> i64 = find_ext_iter(path, 0, -1, -1);

// Get extension (including dot) start position, or path length if none
fn ext_start(path: String) -> i64 =
    let pos = find_ext(path);
    if pos < 0 { path.len() } else { pos };

// Check if path has extension
fn has_extension(path: String) -> bool = find_ext(path) >= 0;

// Get stem (file name without extension) positions
fn stem_start(path: String) -> i64 = basename_start(path);
fn stem_end(path: String) -> i64 = ext_start(path);

// Path component counting
fn count_components_iter(path: String, pos: i64, count: i64, in_component: bool) -> i64 =
    if pos >= path.len() { if in_component { count + 1 } else { count } } else {
        let c = path.byte_at(pos);
        if c == path_sep() { count_components_iter(path, pos + 1, if in_component { count + 1 } else { count }, false) }
        else { count_components_iter(path, pos + 1, count, true) }
    };

fn count_components(path: String) -> i64
  post ret >= 0
= if path.len() == 0 { 0 } else { count_components_iter(path, 0, 0, false) };

// Check for dangerous path components
fn has_parent_ref_at(path: String, pos: i64) -> bool =
    if pos + 1 >= path.len() { false } else { path.byte_at(pos) == 46 and path.byte_at(pos + 1) == 46 };

fn is_safe_path_iter(path: String, pos: i64) -> bool =
    if pos >= path.len() { true } else if has_parent_ref_at(path, pos) { false } else { is_safe_path_iter(path, pos + 1) };

fn is_safe_path(path: String) -> bool =
    is_safe_path_iter(path, 0);

// Normalize path (conceptual - removes redundant separators)
fn count_consecutive_seps(path: String, pos: i64) -> i64 =
    if pos >= path.len() { 0 } else if path.byte_at(pos) != path_sep() { 0 } else { 1 + count_consecutive_seps(path, pos + 1) };

fn needs_normalization(path: String, pos: i64) -> bool =
    if pos + 1 >= path.len() { false } else {
        let c1 = path.byte_at(pos);
        let c2 = path.byte_at(pos + 1);
        (c1 == path_sep() and c2 == path_sep()) or needs_normalization(path, pos + 1)
    };

// Path depth (number of directories from root)
fn path_depth(path: String) -> i64
  post ret >= 0
= let components = count_components(path);
  if is_absolute(path) { components - 1 } else { components };

// Check if path ends with separator
fn ends_with_sep(path: String) -> bool =
    path.len() > 0 and path.byte_at(path.len() - 1) == path_sep();

// Validate path characters (simplified - no null bytes)
fn is_valid_path_char(c: i64) -> bool = c != 0;

fn is_valid_path_iter(path: String, pos: i64) -> bool =
    if pos >= path.len() { true } else if not is_valid_path_char(path.byte_at(pos)) { false } else { is_valid_path_iter(path, pos + 1) };

fn is_valid_path(path: String) -> bool =
    path.len() > 0 and is_valid_path_iter(path, 0);
