// bmb-semver: Semantic Versioning for BMB
// Implements semver 2.0.0 specification: major.minor.patch
// Extracted from gotgan registry module for reuse

// ============================================================
// SECTION 1: VERSION REPRESENTATION
// ============================================================

// Version is represented as packed i64: major * 1000000 + minor * 1000 + patch
// This allows comparison with simple integer operations
// Range: 0.0.0 to 999.999.999

// Pack version components into single i64
fn pack_version(major: i64, minor: i64, patch: i64) -> i64
  pre major >= 0 and major < 1000 and minor >= 0 and minor < 1000 and patch >= 0 and patch < 1000
  post ret >= 0
= major * 1000000 + minor * 1000 + patch;

// Extract major version from packed
fn get_major(packed: i64) -> i64
  pre packed >= 0
  post ret >= 0 and ret < 1000
= packed / 1000000;

// Extract minor version from packed
fn get_minor(packed: i64) -> i64
  pre packed >= 0
  post ret >= 0 and ret < 1000
= (packed / 1000) - (packed / 1000000) * 1000;

// Extract patch version from packed
fn get_patch(packed: i64) -> i64
  pre packed >= 0
  post ret >= 0 and ret < 1000
= packed - (packed / 1000) * 1000;

// ============================================================
// SECTION 2: STRING PARSING HELPERS
// ============================================================

// Check if character is digit (ASCII 48-57)
fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;

// Convert digit char to number
fn digit_value(c: i64) -> i64
  pre c >= 48 and c <= 57
  post ret >= 0 and ret <= 9
= c - 48;

// Parse number from string starting at index, return (value, end_index)
// Uses packed result: value * 10000 + end_index
fn parse_num_iter(s: String, idx: i64, acc: i64, len: i64) -> i64 =
    if idx >= len { acc * 10000 + idx }
    else {
        let c = s.byte_at(idx);
        if is_digit(c) { parse_num_iter(s, idx + 1, acc * 10 + digit_value(c), len) }
        else { acc * 10000 + idx }
    };

fn parse_num(s: String, start: i64) -> i64
  pre start >= 0
= parse_num_iter(s, start, 0, s.len());

// Extract parsed value from packed result
fn parsed_value(packed: i64) -> i64 = packed / 10000;

// Extract end index from packed result
fn parsed_end(packed: i64) -> i64 = packed - (packed / 10000) * 10000;

// ============================================================
// SECTION 3: VERSION STRING PARSING
// ============================================================

// Parse semver string "major.minor.patch" into packed i64
// Returns -1 on parse error
fn parse_version(s: String) -> i64 = {
    let len = s.len();
    if len == 0 { -1 }
    else {
        let r1 = parse_num(s, 0);
        let major = parsed_value(r1);
        let i1 = parsed_end(r1);
        if i1 >= len { -1 }
        else if s.byte_at(i1) != 46 { -1 }
        else {
            let r2 = parse_num(s, i1 + 1);
            let minor = parsed_value(r2);
            let i2 = parsed_end(r2);
            if i2 >= len { -1 }
            else if s.byte_at(i2) != 46 { -1 }
            else {
                let r3 = parse_num(s, i2 + 1);
                let patch = parsed_value(r3);
                pack_version(major, minor, patch)
            }
        }
    }
};

// ============================================================
// SECTION 4: VERSION COMPARISON
// ============================================================

// Compare two versions: -1 if a < b, 0 if a == b, 1 if a > b
fn compare_version(a: i64, b: i64) -> i64
  pre a >= 0 and b >= 0
  post ret >= -1 and ret <= 1
= if a < b { -1 } else if a > b { 1 } else { 0 };

// Compare version strings
fn compare_semver(a: String, b: String) -> i64
  post ret >= -1 and ret <= 1
= compare_version(parse_version(a), parse_version(b));

// Version comparison predicates
fn version_lt(a: i64, b: i64) -> bool = a < b;
fn version_le(a: i64, b: i64) -> bool = a <= b;
fn version_gt(a: i64, b: i64) -> bool = a > b;
fn version_ge(a: i64, b: i64) -> bool = a >= b;
fn version_eq(a: i64, b: i64) -> bool = a == b;

// ============================================================
// SECTION 5: CONSTRAINT TYPES
// ============================================================

// Constraint operators encoded as i64:
// 0 = exact (=)
// 1 = caret (^) - compatible with major
// 2 = tilde (~) - compatible with minor
// 3 = greater than (>)
// 4 = greater or equal (>=)
// 5 = less than (<)
// 6 = less or equal (<=)

fn op_exact() -> i64 = 0;
fn op_caret() -> i64 = 1;
fn op_tilde() -> i64 = 2;
fn op_gt() -> i64 = 3;
fn op_ge() -> i64 = 4;
fn op_lt() -> i64 = 5;
fn op_le() -> i64 = 6;

// ============================================================
// SECTION 6: CONSTRAINT MATCHING
// ============================================================

// Check if version matches caret constraint (^major.minor.patch)
// ^1.2.3 matches >=1.2.3 and <2.0.0
// ^0.2.3 matches >=0.2.3 and <0.3.0
// ^0.0.3 matches >=0.0.3 and <0.0.4
fn matches_caret(ver: i64, cst: i64) -> bool = {
    let vmaj = get_major(ver);
    let cmaj = get_major(cst);
    let vmin = get_minor(ver);
    let cmin = get_minor(cst);
    let vpat = get_patch(ver);
    let cpat = get_patch(cst);
    if cmaj > 0 { vmaj == cmaj and ver >= cst }
    else if cmin > 0 { vmaj == 0 and vmin == cmin and ver >= cst }
    else { vmaj == 0 and vmin == 0 and vpat >= cpat }
};

// Check if version matches tilde constraint (~major.minor.patch)
// ~1.2.3 matches >=1.2.3 and <1.3.0
fn matches_tilde(ver: i64, cst: i64) -> bool = {
    let vmaj = get_major(ver);
    let cmaj = get_major(cst);
    let vmin = get_minor(ver);
    let cmin = get_minor(cst);
    vmaj == cmaj and vmin == cmin and ver >= cst
};

// Check if version matches constraint with given operator
fn matches_constraint(ver: i64, op: i64, cst: i64) -> bool =
    if op == 0 { ver == cst }
    else if op == 1 { matches_caret(ver, cst) }
    else if op == 2 { matches_tilde(ver, cst) }
    else if op == 3 { ver > cst }
    else if op == 4 { ver >= cst }
    else if op == 5 { ver < cst }
    else if op == 6 { ver <= cst }
    else { false };

// ============================================================
// SECTION 7: CONSTRAINT STRING PARSING
// ============================================================

// Parse constraint operator from string start
// Returns packed: operator * 100 + skip_chars
fn parse_constraint_op(s: String) -> i64 = {
    let len = s.len();
    if len == 0 { 0 }
    else {
        let c0 = s.byte_at(0);
        if c0 == 94 { 1 * 100 + 1 }
        else if c0 == 126 { 2 * 100 + 1 }
        else if len >= 2 and c0 == 62 and s.byte_at(1) == 61 { 4 * 100 + 2 }
        else if len >= 2 and c0 == 60 and s.byte_at(1) == 61 { 6 * 100 + 2 }
        else if c0 == 62 { 3 * 100 + 1 }
        else if c0 == 60 { 5 * 100 + 1 }
        else if c0 == 61 { 0 * 100 + 1 }
        else { 0 }
    }
};

// Extract operator from packed result
fn get_op(packed: i64) -> i64 = packed / 100;

// Extract skip chars from packed result
fn get_skip(packed: i64) -> i64 = packed - (packed / 100) * 100;

// ============================================================
// SECTION 8: HIGH-LEVEL API
// ============================================================

// Parse version string, returns -1 on error
fn ver(s: String) -> i64 = parse_version(s);

// Check if version string matches constraint string
// Example: satisfies("1.2.3", "^1.0.0") -> true
fn satisfies(ver_s: String, cst_s: String) -> bool = {
    let ver = parse_version(ver_s);
    if ver < 0 { false }
    else {
        let op_result = parse_constraint_op(cst_s);
        let op = get_op(op_result);
        let skip = get_skip(op_result);
        let cst_ver_s = cst_s.slice(skip, cst_s.len());
        let cst = parse_version(cst_ver_s);
        if cst < 0 { false } else { matches_constraint(ver, op, cst) }
    }
};

// Increment version components
fn inc_major(v: i64) -> i64 = pack_version(get_major(v) + 1, 0, 0);
fn inc_minor(v: i64) -> i64 = pack_version(get_major(v), get_minor(v) + 1, 0);
fn inc_patch(v: i64) -> i64 = pack_version(get_major(v), get_minor(v), get_patch(v) + 1);

// Check if version is stable (major >= 1)
fn is_stable(v: i64) -> bool = get_major(v) >= 1;

// Check if version is prerelease (major == 0)
fn is_prerelease(v: i64) -> bool = get_major(v) == 0;
