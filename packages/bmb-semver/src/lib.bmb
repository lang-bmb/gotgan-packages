// bmb-semver: Semantic Versioning for BMB
// Implements semver 2.0.0 specification: major.minor.patch
// Extracted from gotgan registry module for reuse

// ============================================================
// SECTION 1: VERSION REPRESENTATION
// ============================================================

// Version is represented as packed i64: major * 1000000 + minor * 1000 + patch
// This allows comparison with simple integer operations
// Range: 0.0.0 to 999.999.999

// Pack version components into single i64
fn pack_version(major: i64, minor: i64, patch: i64) -> i64
  pre major >= 0 and major < 1000
  pre minor >= 0 and minor < 1000
  pre patch >= 0 and patch < 1000
  post ret >= 0
= major * 1000000 + minor * 1000 + patch;

// Extract major version from packed
fn get_major(packed: i64) -> i64
  pre packed >= 0
  post ret >= 0 and ret < 1000
= packed / 1000000;

// Extract minor version from packed
fn get_minor(packed: i64) -> i64
  pre packed >= 0
  post ret >= 0 and ret < 1000
= (packed / 1000) - (packed / 1000000) * 1000;

// Extract patch version from packed
fn get_patch(packed: i64) -> i64
  pre packed >= 0
  post ret >= 0 and ret < 1000
= packed - (packed / 1000) * 1000;

// ============================================================
// SECTION 2: STRING PARSING HELPERS
// ============================================================

// Check if character is digit (ASCII 48-57)
fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;

// Convert digit char to number
fn digit_value(c: i64) -> i64
  pre c >= 48 and c <= 57
  post ret >= 0 and ret <= 9
= c - 48;

// Parse number from string starting at index, return (value, end_index)
// Uses packed result: value * 10000 + end_index
fn parse_num_iter(s: str, idx: i64, acc: i64, len: i64) -> i64 =
  if idx >= len { acc * 10000 + idx } else { let c = char_at(s, idx) in
    if is_digit(c) { parse_num_iter(s, idx + 1, acc * 10 + digit_value(c), len) } else { acc * 10000 + idx } };

fn parse_num(s: str, start: i64) -> i64
  pre start >= 0
= parse_num_iter(s, start, 0, str_len(s));

// Extract parsed value from packed result
fn parsed_value(packed: i64) -> i64 = packed / 10000;

// Extract end index from packed result
fn parsed_end(packed: i64) -> i64 = packed - (packed / 10000) * 10000;

// ============================================================
// SECTION 3: VERSION STRING PARSING
// ============================================================

// Parse semver string "major.minor.patch" into packed i64
// Returns -1 on parse error
fn parse_version(s: str) -> i64 =
  let len = str_len(s) in
  if len == 0 { -1 } else { let r1 = parse_num(s, 0) in
    let major = parsed_value(r1) in
    let i1 = parsed_end(r1) in
    if i1 >= len { -1 } else if char_at(s, i1) != 46 { -1  // '.' = 46 } else { let r2 = parse_num(s, i1 + 1) in
      let minor = parsed_value(r2) in
      let i2 = parsed_end(r2) in
      if i2 >= len { -1 } else if char_at(s, i2) != 46 { -1 } else { let r3 = parse_num(s, i2 + 1) in
        let patch = parsed_value(r3) in
        pack_version(major, minor, patch) } } };

// ============================================================
// SECTION 4: VERSION COMPARISON
// ============================================================

// Compare two versions: -1 if a < b, 0 if a == b, 1 if a > b
fn compare_version(a: i64, b: i64) -> i64
  pre a >= 0 and b >= 0
  post ret >= -1 and ret <= 1
= if a < b { -1 } else if a > b { 1 } else { 0 };

// Compare version strings
fn compare_semver(a: str, b: str) -> i64
  post ret >= -1 and ret <= 1
= compare_version(parse_version(a), parse_version(b));

// Version comparison predicates
fn version_lt(a: i64, b: i64) -> bool = a < b;
fn version_le(a: i64, b: i64) -> bool = a <= b;
fn version_gt(a: i64, b: i64) -> bool = a > b;
fn version_ge(a: i64, b: i64) -> bool = a >= b;
fn version_eq(a: i64, b: i64) -> bool = a == b;

// ============================================================
// SECTION 5: CONSTRAINT TYPES
// ============================================================

// Constraint operators encoded as i64:
// 0 = exact (=)
// 1 = caret (^) - compatible with major
// 2 = tilde (~) - compatible with minor
// 3 = greater than (>)
// 4 = greater or equal (>=)
// 5 = less than (<)
// 6 = less or equal (<=)

fn op_exact() -> i64 = 0;
fn op_caret() -> i64 = 1;
fn op_tilde() -> i64 = 2;
fn op_gt() -> i64 = 3;
fn op_ge() -> i64 = 4;
fn op_lt() -> i64 = 5;
fn op_le() -> i64 = 6;

// ============================================================
// SECTION 6: CONSTRAINT MATCHING
// ============================================================

// Check if version matches caret constraint (^major.minor.patch)
// ^1.2.3 matches >=1.2.3 and <2.0.0
// ^0.2.3 matches >=0.2.3 and <0.3.0
// ^0.0.3 matches >=0.0.3 and <0.0.4
fn matches_caret(ver: i64, constraint: i64) -> bool =
  let vmaj = get_major(ver) in
  let cmaj = get_major(constraint) in
  let vmin = get_minor(ver) in
  let cmin = get_minor(constraint) in
  let vpat = get_patch(ver) in
  let cpat = get_patch(constraint) in
  if cmaj > 0 { vmaj == cmaj and ver >= constraint } else if cmin > 0 { vmaj == 0 and vmin == cmin and ver >= constraint } else { vmaj == 0 and vmin == 0 and vpat >= cpat };

// Check if version matches tilde constraint (~major.minor.patch)
// ~1.2.3 matches >=1.2.3 and <1.3.0
fn matches_tilde(ver: i64, constraint: i64) -> bool =
  let vmaj = get_major(ver) in
  let cmaj = get_major(constraint) in
  let vmin = get_minor(ver) in
  let cmin = get_minor(constraint) in
  vmaj == cmaj and vmin == cmin and ver >= constraint;

// Check if version matches constraint with given operator
fn matches_constraint(ver: i64, op: i64, constraint: i64) -> bool =
  if op == 0 { ver == constraint           // exact } else if op == 1 { matches_caret(ver, constraint)   // caret } else if op == 2 { matches_tilde(ver, constraint)   // tilde } else if op == 3 { ver > constraint       // gt } else if op == 4 { ver >= constraint      // ge } else if op == 5 { ver < constraint       // lt } else if op == 6 { ver <= constraint      // le } else { false };

// ============================================================
// SECTION 7: CONSTRAINT STRING PARSING
// ============================================================

// Parse constraint operator from string start
// Returns packed: operator * 100 + skip_chars
fn parse_constraint_op(s: str) -> i64 =
  let len = str_len(s) in
  if len == 0 { 0  // default exact } else { let c0 = char_at(s, 0) in
    if c0 == 94 { 1 * 100 + 1  // ^ caret } else if c0 == 126 { 2 * 100 + 1  // ~ tilde } else if len >= 2 and c0 == 62 and char_at(s, 1) == 61 { 4 * 100 + 2  // >= } else if len >= 2 and c0 == 60 and char_at(s, 1) == 61 { 6 * 100 + 2  // <= } else if c0 == 62 { 3 * 100 + 1  // > } else if c0 == 60 { 5 * 100 + 1  // < } else if c0 == 61 { 0 * 100 + 1  // = } else { 0 } };  // no operator, exact match

// Extract operator from packed result
fn get_op(packed: i64) -> i64 = packed / 100;

// Extract skip chars from packed result
fn get_skip(packed: i64) -> i64 = packed - (packed / 100) * 100;

// ============================================================
// SECTION 8: HIGH-LEVEL API
// ============================================================

// Parse version string, returns -1 on error
fn version(s: str) -> i64 = parse_version(s);

// Check if version string matches constraint string
// Example: satisfies("1.2.3", "^1.0.0") -> true
fn satisfies(ver_str: str, constraint_str: str) -> bool =
  let ver = parse_version(ver_str) in
  if ver < 0 { false } else { let op_result = parse_constraint_op(constraint_str) in
    let op = get_op(op_result) in
    let skip = get_skip(op_result) in
    let constraint_ver_str = str_slice(constraint_str, skip, str_len(constraint_str)) in
    let constraint = parse_version(constraint_ver_str) in
    if constraint < 0 { false } else { matches_constraint(ver, op, constraint) } };

// Increment version components
fn inc_major(v: i64) -> i64 = pack_version(get_major(v) + 1, 0, 0);
fn inc_minor(v: i64) -> i64 = pack_version(get_major(v), get_minor(v) + 1, 0);
fn inc_patch(v: i64) -> i64 = pack_version(get_major(v), get_minor(v), get_patch(v) + 1);

// Check if version is stable (major >= 1)
fn is_stable(v: i64) -> bool = get_major(v) >= 1;

// Check if version is prerelease (major == 0)
fn is_prerelease(v: i64) -> bool = get_major(v) == 0;
