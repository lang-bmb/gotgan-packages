// bmb-regex: Regular expression matching for BMB
// Implements simple pattern matching with basic regex features

// Pattern node types
fn pat_literal() -> i64 = 1;     // exact character match
fn pat_any() -> i64 = 2;         // . (any character)
fn pat_digit() -> i64 = 3;       // \d (digit)
fn pat_alpha() -> i64 = 4;       // \w (word character)
fn pat_space() -> i64 = 5;       // \s (whitespace)
fn pat_start() -> i64 = 6;       // ^ (start anchor)
fn pat_end() -> i64 = 7;         // $ (end anchor)
fn pat_star() -> i64 = 8;        // * (zero or more)
fn pat_plus() -> i64 = 9;        // + (one or more)
fn pat_opt() -> i64 = 10;        // ? (optional)

// Match result codes
fn match_none() -> i64 = -1;
fn match_success() -> i64 = 0;

// Character class checks
fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;
fn is_alpha(c: i64) -> bool = (c >= 65 and c <= 90) or (c >= 97 and c <= 122);
fn is_word(c: i64) -> bool = is_alpha(c) or is_digit(c) or c == 95;
fn is_space(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;

// Match single character against pattern type
fn match_char(c: i64, pat_type: i64, pat_char: i64) -> bool =
    if pat_type == pat_literal() { c == pat_char } else if pat_type == pat_any() { c != 10  // don't match newline } else if pat_type == pat_digit() { is_digit(c) } else if pat_type == pat_alpha() { is_word(c) } else if pat_type == pat_space() { is_space(c) } else { false };

// Simple literal string match
fn match_literal(text: String, pos: i64, pattern: String, pat_pos: i64) -> bool =
    if pat_pos >= pattern.len() { true } else if pos >= text.len() { false } else if text.char_at(pos) == pattern.char_at(pat_pos) { match_literal(text, pos + 1, pattern, pat_pos + 1) } else { false };

// Find literal pattern in text
fn find_literal(text: String, pos: i64, pattern: String) -> i64 =
    if pos + pattern.len() > text.len() { match_none() } else if match_literal(text, pos, pattern, 0) { pos } else { find_literal(text, pos + 1, pattern) };

// Check if text starts with pattern
fn starts_with(text: String, pattern: String) -> bool =
    match_literal(text, 0, pattern, 0);

// Check if text ends with pattern
fn ends_with(text: String, pattern: String) -> bool =
    if pattern.len() > text.len() { false } else { match_literal(text, text.len() - pattern.len(), pattern, 0) };

// Check if text contains pattern
fn contains(text: String, pattern: String) -> bool =
    find_literal(text, 0, pattern) != match_none();

// Count occurrences of pattern in text
fn count_matches_iter(text: String, pos: i64, pattern: String, count: i64) -> i64 =
    if pos + pattern.len() > text.len() { count } else if match_literal(text, pos, pattern, 0) { count_matches_iter(text, pos + pattern.len(), pattern, count + 1) } else { count_matches_iter(text, pos + 1, pattern, count) };

fn count_matches(text: String, pattern: String) -> i64
  post ret >= 0
= if pattern.len() == 0 { 0 } else { count_matches_iter(text, 0, pattern, 0) };

// Match digit sequence (\d+)
fn match_digits(text: String, pos: i64) -> i64 =
    if pos >= text.len() { pos } else if is_digit(text.char_at(pos)) { match_digits(text, pos + 1) } else { pos };

// Match word characters (\w+)
fn match_word(text: String, pos: i64) -> i64 =
    if pos >= text.len() { pos } else if is_word(text.char_at(pos)) { match_word(text, pos + 1) } else { pos };

// Match whitespace (\s+)
fn match_spaces(text: String, pos: i64) -> i64 =
    if pos >= text.len() { pos } else if is_space(text.char_at(pos)) { match_spaces(text, pos + 1) } else { pos };

// Extract digits from text starting at pos
fn extract_number(text: String, pos: i64) -> i64 =
    let end_pos = match_digits(text, pos);
    if end_pos == pos { 0 } else { parse_int(text, pos, end_pos) };

// Parse integer from substring
fn parse_int_iter(text: String, pos: i64, end: i64, acc: i64) -> i64 =
    if pos >= end { acc } else { let c = text.char_at(pos) };
    if is_digit(c) { parse_int_iter(text, pos + 1, end, acc * 10 + (c - 48)) } else { acc };

fn parse_int(text: String, pos: i64, end: i64) -> i64 =
    parse_int_iter(text, pos, end, 0);

// Split by single character (returns count of parts)
fn count_split(text: String, sep: i64) -> i64 =
    count_split_iter(text, 0, sep, 1);

fn count_split_iter(text: String, pos: i64, sep: i64, count: i64) -> i64 =
    if pos >= text.len() { count } else if text.char_at(pos) == sep { count_split_iter(text, pos + 1, sep, count + 1) } else { count_split_iter(text, pos + 1, sep, count) };

// Validate pattern is well-formed (simplified)
fn is_valid_pattern(pattern: String) -> bool =
    pattern.len() > 0 and not (pattern.char_at(0) == 42 or pattern.char_at(0) == 43);
